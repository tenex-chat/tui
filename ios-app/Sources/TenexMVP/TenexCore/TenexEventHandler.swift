import Foundation

// MARK: - Event Handler

/// Handles event callbacks from Rust core and applies deltas to TenexCoreManager.
/// Implements the EventCallback protocol generated by UniFFI.
///
/// Thread Safety: Callbacks are invoked from a background thread in Rust.
/// This handler dispatches all notifications to the main thread for safe UI updates.
final class TenexEventHandler: EventCallback, @unchecked Sendable {
    private unowned let coreManager: TenexCoreManager
    private let lock = NSLock()
    private var pendingDiagnosticsUpdate = false
    private var pendingTeamsUpdate = false
    private var pendingContentCatalogUpdate = false
    private var pendingStatsUpdate = false
    private var pendingGeneralUpdate = false
    private var isFlushScheduled = false

    init(coreManager: TenexCoreManager) {
        self.coreManager = coreManager
    }

    func onDataChanged(changeType: DataChangeType) {
        // Coalesce high-frequency no-payload update signals to avoid main-thread task storms.
        switch changeType {
        case .mcpToolsChanged:
            queueCoalescedUpdate(diagnostics: true)
            return
        case .teamsChanged:
            queueCoalescedUpdate(teams: true)
            return
        case .contentCatalogChanged:
            queueCoalescedUpdate(contentCatalog: true)
            return
        case .statsUpdated:
            queueCoalescedUpdate(stats: true)
            return
        case .diagnosticsUpdated:
            queueCoalescedUpdate(diagnostics: true)
            return
        case .general:
            queueCoalescedUpdate(general: true)
            return
        default:
            break
        }

        Task { @MainActor in
            let coreManager = self.coreManager

            switch changeType {
            case .messageAppended(let conversationId, let message):
                coreManager.applyMessageAppended(conversationId: conversationId, message: message)

            case .conversationUpsert(let conversation):
                coreManager.applyConversationUpsertDelta(conversation)

            case .projectUpsert(let project):
                coreManager.applyProjectUpsert(project)

            case .inboxUpsert(let item):
                coreManager.applyInboxUpsert(item)

                // Only process new events (skip stale inbox items from before this session)
                guard !item.isRead && item.createdAt >= coreManager.sessionStartTimestamp else {
                    break
                }

                if item.eventType == .ask {
                    // Trigger local push notification for ask events
                    Task {
                        await NotificationService.shared.scheduleAskNotification(
                            askEventId: item.id,
                            title: item.title,
                            body: item.content,
                            fromAgent: item.authorPubkey,
                            projectId: item.resolvedProjectId,
                            conversationId: item.threadId
                        )
                    }
                } else if item.eventType == .mention {
                    // Trigger audio notification for mentions
                    Task {
                        await coreManager.triggerAudioNotification(
                            agentPubkey: item.authorPubkey,
                            conversationTitle: item.title,
                            messageText: item.content,
                            conversationId: item.threadId
                        )
                    }
                }

            case .reportUpsert(let report):
                coreManager.applyReportUpsert(report)

            case .projectStatusChanged(let projectId, let projectATag, let isOnline, let onlineAgents):
                coreManager.applyProjectStatusChanged(
                    projectId: projectId,
                    projectATag: projectATag,
                    isOnline: isOnline,
                    onlineAgents: onlineAgents
                )

            case .pendingBackendApproval(let backendPubkey, let projectATag):
                coreManager.handlePendingBackendApproval(
                    backendPubkey: backendPubkey,
                    projectATag: projectATag
                )

            case .activeConversationsChanged(let projectId, let projectATag, let activeConversationIds):
                coreManager.applyActiveConversationsChanged(
                    projectId: projectId,
                    projectATag: projectATag,
                    activeConversationIds: activeConversationIds
                )

            case .streamChunk(let agentPubkey, let conversationId, let textDelta):
                coreManager.applyStreamChunk(
                    agentPubkey: agentPubkey,
                    conversationId: conversationId,
                    textDelta: textDelta
                )

            case .bunkerSignRequest(let request):
                coreManager.handleBunkerSignRequest(request)

            case .bookmarkListChanged(let bookmarkedIds):
                coreManager.applyBookmarkListChanged(bookmarkedIds: bookmarkedIds)

            case .mcpToolsChanged, .teamsChanged, .contentCatalogChanged, .statsUpdated, .diagnosticsUpdated, .general:
                break
            }
        }
    }

    private func queueCoalescedUpdate(
        diagnostics: Bool = false,
        teams: Bool = false,
        contentCatalog: Bool = false,
        stats: Bool = false,
        general: Bool = false
    ) {
        var shouldScheduleFlush = false

        lock.lock()
        pendingDiagnosticsUpdate = pendingDiagnosticsUpdate || diagnostics
        pendingTeamsUpdate = pendingTeamsUpdate || teams
        pendingContentCatalogUpdate = pendingContentCatalogUpdate || contentCatalog
        pendingStatsUpdate = pendingStatsUpdate || stats
        pendingGeneralUpdate = pendingGeneralUpdate || general
        if !isFlushScheduled {
            isFlushScheduled = true
            shouldScheduleFlush = true
        }
        lock.unlock()

        guard shouldScheduleFlush else { return }

        Task { @MainActor [weak self] in
            // Batch bursts arriving in the same scheduling window.
            try? await Task.sleep(nanoseconds: 40_000_000)
            self?.flushCoalescedUpdates()
        }
    }

    @MainActor
    private func flushCoalescedUpdates() {
        let shouldSignalDiagnostics: Bool
        let shouldSignalTeams: Bool
        let shouldSignalContentCatalog: Bool
        let shouldSignalStats: Bool
        let shouldSignalGeneral: Bool

        lock.lock()
        shouldSignalDiagnostics = pendingDiagnosticsUpdate
        shouldSignalTeams = pendingTeamsUpdate
        shouldSignalContentCatalog = pendingContentCatalogUpdate
        shouldSignalStats = pendingStatsUpdate
        shouldSignalGeneral = pendingGeneralUpdate

        pendingDiagnosticsUpdate = false
        pendingTeamsUpdate = false
        pendingContentCatalogUpdate = false
        pendingStatsUpdate = false
        pendingGeneralUpdate = false
        isFlushScheduled = false
        lock.unlock()

        let coreManager = self.coreManager

        if shouldSignalTeams {
            coreManager.signalTeamsUpdate()
        }
        if shouldSignalContentCatalog {
            coreManager.signalContentCatalogUpdate()
        }
        if shouldSignalStats {
            coreManager.signalStatsUpdate()
        }
        if shouldSignalDiagnostics {
            coreManager.signalDiagnosticsUpdate()
        }
        if shouldSignalGeneral {
            coreManager.signalGeneralUpdate()
        }
    }
}
