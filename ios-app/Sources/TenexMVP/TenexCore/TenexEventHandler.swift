import Foundation

// MARK: - Event Handler

/// Handles event callbacks from Rust core and applies deltas to TenexCoreManager.
/// Implements the EventCallback protocol generated by UniFFI.
///
/// Thread Safety: Callbacks are invoked from a background thread in Rust.
/// This handler dispatches all notifications to the main thread for safe UI updates.
final class TenexEventHandler: EventCallback {
    weak var coreManager: TenexCoreManager?

    init(coreManager: TenexCoreManager) {
        self.coreManager = coreManager
    }

    func onDataChanged(changeType: DataChangeType) {
        Task { @MainActor [weak self] in
            guard let coreManager = self?.coreManager else { return }

            switch changeType {
            case .messageAppended(let conversationId, _):
                coreManager.signalConversationUpdate(conversationId: conversationId)

            case .conversationUpsert(let conversation):
                coreManager.signalConversationUpdate(conversationId: conversation.id)

            case .projectUpsert(let project):
                coreManager.applyProjectUpsert(project)

            case .inboxUpsert(let item):
                coreManager.applyInboxUpsert(item)

                // Trigger audio notification for mentions (high priority = p-tag mention)
                // Run in background to avoid blocking the event handler
                if item.eventType == "mention" && item.status == "waiting" {
                    Task {
                        await coreManager.triggerAudioNotification(
                            agentPubkey: item.authorPubkey,
                            conversationTitle: item.title,
                            messageText: item.content,
                            conversationId: item.conversationId
                        )
                    }
                }

            case .projectStatusChanged(let projectId, let projectATag, let isOnline, let onlineAgents):
                coreManager.applyProjectStatusChanged(
                    projectId: projectId,
                    projectATag: projectATag,
                    isOnline: isOnline,
                    onlineAgents: onlineAgents
                )

            case .pendingBackendApproval(let backendPubkey, let projectATag):
                coreManager.handlePendingBackendApproval(
                    backendPubkey: backendPubkey,
                    projectATag: projectATag
                )

            case .activeConversationsChanged(let projectId, let projectATag, let activeConversationIds):
                coreManager.applyActiveConversationsChanged(
                    projectId: projectId,
                    projectATag: projectATag,
                    activeConversationIds: activeConversationIds
                )

            case .streamChunk(let agentPubkey, let conversationId, let textDelta):
                coreManager.applyStreamChunk(
                    agentPubkey: agentPubkey,
                    conversationId: conversationId,
                    textDelta: textDelta
                )

            case .mcpToolsChanged:
                coreManager.signalGeneralUpdate()

            case .statsUpdated:
                coreManager.signalGeneralUpdate()

            case .diagnosticsUpdated:
                coreManager.signalGeneralUpdate()

            case .general:
                coreManager.signalGeneralUpdate()
            }
        }
    }
}
