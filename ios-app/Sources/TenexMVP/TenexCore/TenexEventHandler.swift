import Foundation

// MARK: - Notification Names

extension Notification.Name {
    /// Posted when messages change for a conversation.
    /// Object: conversation ID (String)
    static let tenexMessagesChanged = Notification.Name("tenexMessagesChanged")

    /// Posted when a streaming text chunk arrives.
    /// UserInfo keys: "agentPubkey", "conversationId", "textDelta" (optional)
    static let tenexStreamChunk = Notification.Name("tenexStreamChunk")

    /// Posted when project status changes (kind:24010).
    static let tenexProjectStatusChanged = Notification.Name("tenexProjectStatusChanged")

    /// Posted when any data changes and a general refresh is recommended.
    static let tenexDataChanged = Notification.Name("tenexDataChanged")
}

// MARK: - Event Handler

/// Handles event callbacks from Rust core and dispatches to UI via NotificationCenter.
/// Implements the EventCallback protocol generated by UniFFI.
///
/// Thread Safety: Callbacks are invoked from a background thread in Rust.
/// This handler dispatches all notifications to the main thread for safe UI updates.
final class TenexEventHandler: EventCallback {
    weak var coreManager: TenexCoreManager?

    init(coreManager: TenexCoreManager) {
        self.coreManager = coreManager
    }

    /// Refresh projectOnlineStatus and onlineAgents for all known projects.
    /// Called when Rust pushes a projectStatus change event.
    /// Must be called from main thread.
    @MainActor
    private func refreshProjectOnlineStatuses(coreManager: TenexCoreManager) {
        // Get current projects and update their online status
        let projects = coreManager.projects
        var newStatus: [String: Bool] = [:]

        for project in projects {
            // Use the synchronous core API directly (we're already on main thread,
            // and this is a quick in-memory lookup in the Rust layer)
            let isOnline = coreManager.core.isProjectOnline(projectId: project.id)
            newStatus[project.id] = isOnline

            // Proactively fetch and cache online agents for online projects
            // This eliminates the multi-second delay when opening agent selector
            if isOnline {
                Task {
                    await coreManager.fetchAndCacheAgents(for: project.id)
                }
            } else {
                // Clear agents for offline projects immediately
                coreManager.onlineAgents[project.id] = []
            }
        }

        // Update the published dictionaries - SwiftUI will react automatically
        coreManager.projectOnlineStatus = newStatus
    }

    /// Called by Rust when data has changed.
    /// Dispatches to main thread and calls targeted refresh methods on TenexCoreManager.
    ///
    /// **Performance Note:** We use targeted @Published property updates instead of
    /// objectWillChange.send() to avoid triggering full UI refresh. Each change type
    /// only updates the specific data stores that are affected.
    func onDataChanged(changeType: DataChangeType) {
        DispatchQueue.main.async { [weak self] in
            guard let coreManager = self?.coreManager else { return }

            switch changeType {
            case .messages(let conversationId):
                // Post notification for conversation-specific refresh (for detail views)
                NotificationCenter.default.post(
                    name: .tenexMessagesChanged,
                    object: conversationId
                )
                // Update only conversations list via @Published property (not objectWillChange)
                Task { @MainActor in
                    await coreManager.onMessagesChanged(conversationId: conversationId)
                }

            case .projectStatus:
                // Update the reactive projectOnlineStatus dictionary
                // This is called from main thread already, so safe to update @Published
                self?.refreshProjectOnlineStatuses(coreManager: coreManager)

                // Post project status notification for any other subscribers
                NotificationCenter.default.post(
                    name: .tenexProjectStatusChanged,
                    object: nil
                )
                // Update only projects via @Published property
                Task { @MainActor in
                    await coreManager.onProjectStatusChanged()
                }

            case .streamChunk(let agentPubkey, let conversationId, let textDelta):
                // Post streaming notification with details
                // No state update needed - just notification for active stream views
                NotificationCenter.default.post(
                    name: .tenexStreamChunk,
                    object: nil,
                    userInfo: [
                        "agentPubkey": agentPubkey,
                        "conversationId": conversationId,
                        "textDelta": textDelta as Any
                    ]
                )

            case .general:
                // Post general data changed notification
                NotificationCenter.default.post(
                    name: .tenexDataChanged,
                    object: nil
                )
                // Refresh all data stores via @Published properties
                Task { @MainActor in
                    await coreManager.onGeneralDataChanged()
                }
            }
        }
    }
}
