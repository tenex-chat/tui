# Swift Bindings - Agent Guidelines

## Overview

This directory contains **auto-generated** Swift bindings from Rust code using UniFFI.

**⚠️ DO NOT EDIT FILES IN THIS DIRECTORY MANUALLY**

Files here are generated by `uniffi-bindgen` and will be overwritten on regeneration.

## Contents

- **tenex_core.swift** - Swift interface to Rust functions/types
- **tenex_coreFFI.h** - C header with FFI declarations
- **tenex_coreFFI.modulemap** - Swift module map for importing

## Generation Command

```bash
# From project root
cargo bin uniffi-bindgen generate \
  --library target/aarch64-apple-ios-sim/release/libtenex_core.a \
  --language swift \
  --out-dir swift-bindings \
  crates/tenex-core/src/tenex_core.udl
```

**When to regenerate:**
1. After changing Rust FFI functions in `crates/tenex-core/src/ffi.rs`
2. After modifying the UDL interface definition (if separate UDL file exists)
3. After adding/removing UniFFI types or enums
4. When Swift compilation errors suggest FFI mismatch

## Integration with iOS

After regenerating bindings, copy to iOS project:

```bash
# Copy bindings to iOS FFI directory
cp swift-bindings/tenex_core.swift ios-app/Sources/TenexMVP/TenexCoreFFI/
cp swift-bindings/tenex_coreFFI.h ios-app/Sources/TenexMVP/TenexCoreFFI/
cp swift-bindings/tenex_coreFFI.modulemap ios-app/Sources/TenexMVP/TenexCoreFFI/
```

Or use the iOS app's configured paths to reference directly.

## How UniFFI Works

### Rust Side (crates/tenex-core)

```rust
// In ffi.rs or lib.rs
uniffi::setup_scaffolding!();

#[uniffi::export]
pub fn rust_function(arg: String) -> Result<String, TenexError> {
    Ok(format!("Hello, {}", arg))
}

#[derive(uniffi::Record)]
pub struct MyStruct {
    pub field: String,
}

#[derive(uniffi::Error, thiserror::Error)]
pub enum TenexError {
    #[error("Something went wrong: {0}")]
    Generic(String),
}
```

### Generated Swift (this directory)

```swift
// Auto-generated in tenex_core.swift
public func rustFunction(arg: String) throws -> String {
    // FFI bridge implementation
}

public struct MyStruct {
    public var field: String
}

public enum TenexError: Error {
    case Generic(String)
}
```

### Usage in iOS

```swift
import tenex_coreFFI

do {
    let result = try rustFunction(arg: "World")
    print(result) // "Hello, World"
} catch let error as TenexError {
    print("Error: \(error)")
}
```

## UniFFI Type Mapping

| Rust | Swift | Notes |
|------|-------|-------|
| `String` | `String` | UTF-8 |
| `bool` | `Bool` | |
| `i32`, `i64` | `Int32`, `Int64` | |
| `u32`, `u64` | `UInt32`, `UInt64` | |
| `f32`, `f64` | `Float`, `Double` | |
| `Vec<T>` | `[T]` | |
| `HashMap<K,V>` | `[K: V]` | |
| `Option<T>` | `T?` | |
| `Result<T, E>` | throws `E` | |
| `Arc<T>` | Opaque handle | Shared ownership |

## Common Issues

### Regeneration Fails

**Error: "Could not find cdylib"**
- Build Rust library first: `cargo build --target aarch64-apple-ios-sim --release -p tenex-core`

**Error: "UDL parse error"**
- Check UDL syntax if using separate UDL file
- Ensure all types referenced in UDL are defined in Rust

### Swift Compilation Errors

**Error: "Cannot find 'FunctionName' in scope"**
- Regenerate bindings after Rust changes
- Ensure function is marked with `#[uniffi::export]`

**Error: "Type mismatch"**
- Rust type changed but Swift code still uses old type
- Regenerate bindings and update Swift code

### Runtime Errors

**Error: "Symbol not found: _uniffi_tenex_core_*"**
- Rust library not linked properly
- Check Xcode build settings for library search paths
- Verify `OTHER_LDFLAGS` includes path to `libtenex_core.a`

## Best Practices

### Adding New FFI Functions

1. **Define in Rust** (crates/tenex-core/src/ffi.rs):
```rust
#[uniffi::export]
pub fn new_feature(param: String) -> Result<Data, TenexError> {
    // Implementation
}
```

2. **Regenerate bindings**:
```bash
cargo bin uniffi-bindgen generate ...
```

3. **Copy to iOS project** (if needed)

4. **Use in Swift**:
```swift
let data = try newFeature(param: "value")
```

### Type Design

**Use simple types across FFI:**
- Prefer flat structs over nested complex types
- Use enums for error cases
- Avoid references/lifetimes (not supported)

**For complex types:**
- Use opaque Arc handles in Rust
- Expose methods on those handles
- Swift gets object-like API

Example:
```rust
#[derive(uniffi::Object)]
pub struct ComplexObject {
    // Internal fields
}

#[uniffi::export]
impl ComplexObject {
    pub fn new() -> Arc<Self> {
        Arc::new(Self { /* ... */ })
    }

    pub fn method(&self) -> String {
        // Implementation
    }
}
```

Swift usage:
```swift
let obj = ComplexObject()
let result = obj.method()
```

## Debugging

### Check Generated Code
```bash
# View generated Swift interface
cat swift-bindings/tenex_core.swift | less

# Check FFI header
cat swift-bindings/tenex_coreFFI.h | less
```

### Verify Library Symbols
```bash
# List symbols in static library
nm -g target/aarch64-apple-ios-sim/release/libtenex_core.a | grep uniffi

# Check for specific function
nm -g target/aarch64-apple-ios-sim/release/libtenex_core.a | grep my_function
```

## Related

- [../crates/tenex-core/AGENTS.md](../crates/tenex-core/AGENTS.md) - Rust FFI implementation
- [../ios-app/AGENTS.md](../ios-app/AGENTS.md) - iOS integration
- [UniFFI Book](https://mozilla.github.io/uniffi-rs/) - Official documentation
